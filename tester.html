<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QA API Playground</title>
  <style>
    :root {
      --bg: #09111c;
      --bg-elev: #111c2c;
      --bg-soft: #1a2a40;
      --line: #28405f;
      --text: #e3edf8;
      --muted: #93aac7;
      --accent: #35c0ff;
      --accent-soft: #1a6f8f;
      --good: #2fd884;
      --warn: #ffb938;
      --bad: #ff6c6c;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 500px at 80% -100px, rgba(53, 192, 255, 0.18), transparent),
        radial-gradient(900px 450px at -150px 120%, rgba(255, 185, 56, 0.12), transparent),
        var(--bg);
      padding: 16px;
    }

    .app {
      max-width: 1500px;
      margin: 0 auto;
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: hidden;
      background: rgba(8, 14, 23, 0.82);
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.3);
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 14px 18px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(120deg, rgba(17, 28, 44, 0.85), rgba(22, 32, 50, 0.65));
    }

    .title-wrap h1 {
      font-size: 18px;
      letter-spacing: 0.2px;
    }

    .title-wrap p {
      color: var(--muted);
      font-size: 13px;
      margin-top: 2px;
    }

    .topbar-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .label-inline {
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input,
    .select,
    .textarea {
      width: 100%;
      border: 1px solid var(--line);
      background: #0b1523;
      color: var(--text);
      border-radius: 8px;
      padding: 10px 11px;
      font-size: 13px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      outline: none;
    }

    .input:focus,
    .select:focus,
    .textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(53, 192, 255, 0.2);
    }

    .btn {
      border: 1px solid var(--line);
      background: var(--bg-soft);
      color: var(--text);
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.12s ease, opacity 0.12s ease;
    }

    .btn:hover {
      opacity: 0.92;
      transform: translateY(-1px);
    }

    .btn.primary {
      background: linear-gradient(140deg, var(--accent), #1ca3de);
      border-color: #1590c6;
      color: #04101a;
    }

    .conn {
      font-size: 12px;
      color: var(--muted);
      min-width: 100px;
    }

    .layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      min-height: 760px;
    }

    .sidebar {
      border-right: 1px solid var(--line);
      padding: 14px;
      background: rgba(12, 19, 31, 0.9);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .card {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(17, 28, 44, 0.82);
      overflow: hidden;
    }

    .card-head {
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.55px;
      font-weight: 700;
    }

    .collection {
      max-height: 430px;
      overflow-y: auto;
    }

    .endpoint-item {
      width: 100%;
      border: 0;
      border-bottom: 1px solid rgba(40, 64, 95, 0.65);
      background: transparent;
      color: var(--text);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      text-align: left;
      cursor: pointer;
    }

    .endpoint-item:last-child {
      border-bottom: 0;
    }

    .endpoint-item:hover,
    .endpoint-item.active {
      background: rgba(53, 192, 255, 0.1);
    }

    .method-pill {
      min-width: 58px;
      text-align: center;
      border-radius: 5px;
      font-size: 11px;
      font-weight: 700;
      padding: 3px 6px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }

    .method-GET { background: rgba(47, 216, 132, 0.2); color: #89f2be; }
    .method-POST { background: rgba(53, 192, 255, 0.2); color: #9adfff; }
    .method-PUT { background: rgba(255, 185, 56, 0.22); color: #ffd580; }
    .method-PATCH { background: rgba(240, 117, 70, 0.2); color: #ffc39f; }
    .method-DELETE { background: rgba(255, 108, 108, 0.2); color: #ffb4b4; }

    .endpoint-path {
      font-size: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      color: #d6e4f6;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tip {
      padding: 10px 12px;
      font-size: 12px;
      line-height: 1.5;
      color: #d9e6f7;
      background: rgba(255, 185, 56, 0.08);
      border-left: 3px solid var(--warn);
    }

    .history {
      max-height: 190px;
      overflow-y: auto;
      font-size: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
    }

    .history-item {
      padding: 8px 11px;
      border-bottom: 1px solid rgba(40, 64, 95, 0.65);
      color: #c9d9ed;
    }

    .history-item:last-child {
      border-bottom: 0;
    }

    .history-empty {
      padding: 12px;
      color: var(--muted);
      font-size: 12px;
    }

    .main {
      padding: 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 14px;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(17, 28, 44, 0.75);
      overflow: hidden;
    }

    .panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 700;
    }

    .request-grid {
      padding: 12px;
      display: grid;
      gap: 12px;
    }

    .request-line {
      display: grid;
      grid-template-columns: 130px 1fr auto;
      gap: 10px;
      align-items: center;
    }

    .final-url {
      border: 1px dashed var(--line);
      border-radius: 8px;
      padding: 9px 10px;
      font-size: 12px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      color: #c7d9f1;
      background: rgba(11, 21, 35, 0.75);
      word-break: break-all;
    }

    .tab-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab-btn {
      border: 1px solid var(--line);
      background: rgba(12, 24, 38, 0.75);
      color: var(--muted);
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    .tab-btn.active {
      border-color: #1988b6;
      color: #dcf4ff;
      background: rgba(53, 192, 255, 0.17);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    .grid-two {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .kv-head,
    .kv-row {
      display: grid;
      grid-template-columns: 54px 1fr 1fr 34px;
      gap: 7px;
      align-items: center;
    }

    .kv-head {
      padding: 0 0 7px;
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.45px;
    }

    .kv-list {
      display: grid;
      gap: 7px;
      max-height: 180px;
      overflow-y: auto;
      padding-right: 2px;
    }

    .check {
      width: 17px;
      height: 17px;
      margin-left: 7px;
      accent-color: var(--accent);
    }

    .row-del {
      border: 0;
      border-radius: 7px;
      height: 34px;
      width: 34px;
      background: rgba(255, 108, 108, 0.15);
      color: #ffc5c5;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
    }

    .row-del:hover {
      background: rgba(255, 108, 108, 0.25);
    }

    .path-param-list {
      display: grid;
      gap: 8px;
      max-width: 620px;
    }

    .path-param-row {
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 8px;
      align-items: center;
    }

    .key-chip {
      border: 1px solid var(--line);
      border-radius: 7px;
      padding: 8px 10px;
      font-size: 12px;
      color: #bdd1ea;
      background: rgba(10, 18, 30, 0.75);
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
    }

    .empty {
      color: var(--muted);
      font-size: 12px;
      padding: 12px;
      border: 1px dashed var(--line);
      border-radius: 8px;
      background: rgba(10, 18, 30, 0.55);
      max-width: 620px;
    }

    .note {
      color: #c8daee;
      font-size: 12px;
      line-height: 1.45;
      border-left: 3px solid var(--accent-soft);
      background: rgba(53, 192, 255, 0.09);
      padding: 10px 12px;
      border-radius: 0 8px 8px 0;
    }

    .textarea {
      min-height: 185px;
      resize: vertical;
      line-height: 1.45;
    }

    .body-tools {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .response-layout {
      display: grid;
      grid-template-rows: auto auto 1fr;
      height: 100%;
      min-height: 0;
    }

    .response-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      font-size: 12px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 5px 10px;
      font-weight: 700;
      border: 1px solid var(--line);
      background: rgba(10, 18, 30, 0.8);
      color: #e2eefb;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
    }

    .chip.good { border-color: rgba(47, 216, 132, 0.55); color: #95f3c1; }
    .chip.warn { border-color: rgba(255, 185, 56, 0.55); color: #ffd990; }
    .chip.bad { border-color: rgba(255, 108, 108, 0.55); color: #ffc2c2; }

    .resp-tabs {
      display: flex;
      gap: 8px;
      padding: 9px 12px;
      border-bottom: 1px solid var(--line);
    }

    .resp-content {
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    pre {
      margin: 0;
      padding: 12px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      white-space: pre;
      background: rgba(10, 18, 30, 0.74);
      flex: 1;
    }

    .resp-pane {
      display: none;
      height: 100%;
    }

    .resp-pane.active {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .muted {
      color: var(--muted);
    }

    @media (max-width: 1150px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .sidebar {
        border-right: 0;
        border-bottom: 1px solid var(--line);
      }

      .collection {
        max-height: 240px;
      }
    }

    @media (max-width: 780px) {
      .topbar {
        align-items: flex-start;
        flex-direction: column;
      }

      .request-line {
        grid-template-columns: 1fr;
      }

      .grid-two {
        grid-template-columns: 1fr;
      }

      .path-param-row {
        grid-template-columns: 1fr;
      }

      .kv-head,
      .kv-row {
        grid-template-columns: 42px 1fr 1fr 32px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="title-wrap">
        <h1>QA API Playground</h1>
        <p>Interface no estilo Postman para testar a API de vagas no navegador.</p>
      </div>

      <div class="topbar-actions">
        <span class="label-inline">Base URL</span>
        <input class="input" id="baseUrl" value="http://localhost:3000" style="min-width: 250px;">
        <button class="btn" id="pingBtn">Testar conexão</button>
        <span class="conn" id="connText">Aguardando teste</span>
      </div>
    </header>

    <div class="layout">
      <aside class="sidebar">
        <section class="card">
          <div class="card-head">Collection</div>
          <div class="collection" id="collectionList"></div>
        </section>

        <section class="card">
          <div class="card-head">Dica QA</div>
          <div class="tip" id="bugHint">
            Selecione um endpoint na collection para ver sugestões de cenários de bug.
          </div>
        </section>

        <section class="card">
          <div class="card-head">Histórico local</div>
          <div class="history" id="historyList">
            <div class="history-empty">Nenhuma requisição enviada ainda.</div>
          </div>
        </section>
      </aside>

      <main class="main">
        <section class="panel">
          <div class="panel-head">
            <span>Request Builder</span>
            <span class="muted">Ctrl/Cmd + Enter para enviar</span>
          </div>

          <div class="request-grid">
            <div class="request-line">
              <select class="select" id="methodSelect">
                <option>GET</option>
                <option>POST</option>
                <option>PUT</option>
                <option>PATCH</option>
                <option>DELETE</option>
              </select>
              <input class="input" id="pathInput" placeholder="/api/jobs">
              <button class="btn primary" id="sendBtn">Enviar</button>
            </div>

            <div class="final-url" id="finalUrlPreview">URL final: -</div>

            <div class="tab-buttons" id="requestTabs">
              <button class="tab-btn active" data-tab="path">Path Params</button>
              <button class="tab-btn" data-tab="query">Query Params</button>
              <button class="tab-btn" data-tab="headers">Headers</button>
              <button class="tab-btn" data-tab="body">Body</button>
            </div>

            <div class="tab-panel active" data-panel="path">
              <div class="path-param-list" id="pathParamsList"></div>
            </div>

            <div class="tab-panel" data-panel="query">
              <div class="kv-head">
                <span>On</span>
                <span>Key</span>
                <span>Value</span>
                <span></span>
              </div>
              <div class="kv-list" id="queryRows"></div>
              <button class="btn" id="addQueryBtn" style="margin-top: 8px;">+ Adicionar query param</button>
            </div>

            <div class="tab-panel" data-panel="headers">
              <div class="kv-head">
                <span>On</span>
                <span>Key</span>
                <span>Value</span>
                <span></span>
              </div>
              <div class="kv-list" id="headerRows"></div>
              <button class="btn" id="addHeaderBtn" style="margin-top: 8px;">+ Adicionar header</button>
            </div>

            <div class="tab-panel" data-panel="body">
              <div class="body-tools">
                <label class="label-inline" for="bodyMode" style="margin-right: 3px;">Body Type</label>
                <select class="select" id="bodyMode" style="max-width: 220px;">
                  <option value="none">Sem body</option>
                  <option value="json">JSON</option>
                  <option value="text">Texto bruto</option>
                </select>
                <button class="btn" id="formatJsonBtn">Formatar JSON</button>
              </div>
              <textarea class="textarea" id="bodyInput" placeholder='{"title":"Dev","company":"Empresa","location":"Remoto"}'></textarea>
            </div>

            <div class="note" id="requestNote">
              Use a collection para carregar requests prontos e depois altere parâmetros para reproduzir cenários de erro.
            </div>
          </div>
        </section>

        <section class="panel response-layout">
          <div class="panel-head">
            <span>Response</span>
            <button class="btn" id="copyRespBtn">Copiar resposta</button>
          </div>

          <div class="response-meta">
            <span class="chip" id="statusChip">Status: -</span>
            <span class="chip" id="timeChip">Tempo: -</span>
            <span class="chip" id="sizeChip">Tamanho: -</span>
          </div>

          <div class="resp-content">
            <div class="resp-tabs" id="responseTabs">
              <button class="tab-btn active" data-resp-tab="body">Body</button>
              <button class="tab-btn" data-resp-tab="headers">Headers</button>
              <button class="tab-btn" data-resp-tab="request">Request</button>
            </div>

            <div class="resp-pane active" data-resp-panel="body">
              <pre id="responseBody">Envie uma requisição para visualizar a resposta.</pre>
            </div>
            <div class="resp-pane" data-resp-panel="headers">
              <pre id="responseHeaders">-</pre>
            </div>
            <div class="resp-pane" data-resp-panel="request">
              <pre id="requestPreview">-</pre>
            </div>
          </div>
        </section>
      </main>
    </div>
  </div>

  <script>
    const endpointCollection = [
      {
        name: "Listar vagas",
        method: "GET",
        path: "/api/jobs",
        hint: "Teste order=asc/desc e compare o retorno. Verifique filtros search, salary_min e salary_max.",
        query: [
          { enabled: true, key: "page", value: "1" },
          { enabled: true, key: "limit", value: "10" },
          { enabled: true, key: "sort", value: "created_at" },
          { enabled: true, key: "order", value: "desc" },
          { enabled: false, key: "search", value: "React" },
          { enabled: false, key: "salary_min", value: "5000" },
          { enabled: false, key: "salary_max", value: "12000" }
        ],
        headers: [
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "none",
        body: "",
        note: "Use os filtros para montar os cenários de validação de paginação e ordenação."
      },
      {
        name: "Buscar vaga por ID",
        method: "GET",
        path: "/api/jobs/:id",
        pathParams: { id: "1" },
        hint: "Teste um ID existente e outro inexistente (ex: 99999) e valide status code e formato de erro.",
        query: [],
        headers: [
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "none",
        body: "",
        note: "O comportamento para ID inexistente deve seguir a documentação."
      },
      {
        name: "Estatísticas",
        method: "GET",
        path: "/api/jobs/stats/summary",
        hint: "Confira se total = active + inactive e se os agregados fazem sentido.",
        query: [],
        headers: [
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "none",
        body: "",
        note: "Endpoint útil para checar consistência de dados da API."
      },
      {
        name: "Criar vaga",
        method: "POST",
        path: "/api/jobs",
        hint: "Teste campos obrigatórios, type/level inválidos, salary_min > salary_max e descrição longa.",
        query: [],
        headers: [
          { enabled: true, key: "Content-Type", value: "application/json" },
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "json",
        body: JSON.stringify({
          title: "QA Engineer",
          company: "Empresa XPTO",
          location: "Remoto",
          salary_min: 4000,
          salary_max: 7000,
          type: "CLT",
          level: "junior",
          description: "Atuar com testes manuais e automatizados.",
          requirements: "Postman, API testing",
          status: "active"
        }, null, 2),
        note: "Valide payload e status HTTP."
      },
      {
        name: "Atualizar vaga (PUT)",
        method: "PUT",
        path: "/api/jobs/:id",
        pathParams: { id: "1" },
        hint: "Envie body completo e compare updated_at antes/depois.",
        query: [],
        headers: [
          { enabled: true, key: "Content-Type", value: "application/json" },
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "json",
        body: JSON.stringify({
          title: "QA Engineer Senior",
          company: "Empresa XPTO",
          location: "Sao Paulo",
          salary_min: 7000,
          salary_max: 12000,
          type: "CLT",
          level: "senior",
          description: "Lideranca tecnica de qualidade.",
          requirements: "API + E2E",
          status: "active"
        }, null, 2),
        note: "PUT deve exigir os campos obrigatórios e atualizar metadados."
      },
      {
        name: "Atualizar vaga (PATCH)",
        method: "PATCH",
        path: "/api/jobs/:id",
        pathParams: { id: "1" },
        hint: "Teste payload parcial válido e payload com campos inválidos.",
        query: [],
        headers: [
          { enabled: true, key: "Content-Type", value: "application/json" },
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "json",
        body: JSON.stringify({
          status: "inactive",
          salary_max: 15000
        }, null, 2),
        note: "PATCH deve atualizar somente os campos permitidos e refletir updated_at."
      },
      {
        name: "Remover vaga",
        method: "DELETE",
        path: "/api/jobs/:id",
        pathParams: { id: "1" },
        hint: "Delete e depois faça GET no mesmo ID para validar exclusão real e resposta correta.",
        query: [],
        headers: [
          { enabled: true, key: "Accept", value: "application/json" }
        ],
        bodyMode: "none",
        body: "",
        note: "Cheque estrutura de dados retornada na resposta de remoção."
      }
    ];

    const collectionList = document.getElementById("collectionList");
    const bugHint = document.getElementById("bugHint");
    const historyList = document.getElementById("historyList");

    const baseUrlInput = document.getElementById("baseUrl");
    const connText = document.getElementById("connText");
    const methodSelect = document.getElementById("methodSelect");
    const pathInput = document.getElementById("pathInput");
    const finalUrlPreview = document.getElementById("finalUrlPreview");

    const pathParamsList = document.getElementById("pathParamsList");
    const queryRows = document.getElementById("queryRows");
    const headerRows = document.getElementById("headerRows");
    const addQueryBtn = document.getElementById("addQueryBtn");
    const addHeaderBtn = document.getElementById("addHeaderBtn");

    const bodyMode = document.getElementById("bodyMode");
    const bodyInput = document.getElementById("bodyInput");
    const requestNote = document.getElementById("requestNote");

    const statusChip = document.getElementById("statusChip");
    const timeChip = document.getElementById("timeChip");
    const sizeChip = document.getElementById("sizeChip");
    const responseBody = document.getElementById("responseBody");
    const responseHeaders = document.getElementById("responseHeaders");
    const requestPreview = document.getElementById("requestPreview");

    const localHistory = [];
    let currentPathParamValues = {};
    let activeEndpointIndex = -1;
    let lastResponseText = "";

    function createMethodPill(method) {
      const span = document.createElement("span");
      span.className = `method-pill method-${method.toUpperCase()}`;
      span.textContent = method;
      return span;
    }

    function createEndpointButton(endpoint, index) {
      const button = document.createElement("button");
      button.className = "endpoint-item";
      button.type = "button";

      const path = document.createElement("span");
      path.className = "endpoint-path";
      path.textContent = endpoint.path;

      button.append(createMethodPill(endpoint.method));
      button.append(path);

      button.addEventListener("click", () => {
        loadEndpoint(index);
      });

      return button;
    }

    function renderCollection() {
      collectionList.innerHTML = "";
      endpointCollection.forEach((endpoint, index) => {
        collectionList.append(createEndpointButton(endpoint, index));
      });
    }

    function setCollectionActive(index) {
      const buttons = collectionList.querySelectorAll(".endpoint-item");
      buttons.forEach((button, btnIndex) => {
        button.classList.toggle("active", btnIndex === index);
      });
    }

    function createKvRow(container, data) {
      const row = document.createElement("div");
      row.className = "kv-row";

      const check = document.createElement("input");
      check.type = "checkbox";
      check.className = "check";
      check.checked = Boolean(data.enabled);

      const key = document.createElement("input");
      key.className = "input";
      key.value = data.key || "";
      key.placeholder = "key";

      const value = document.createElement("input");
      value.className = "input";
      value.value = data.value || "";
      value.placeholder = "value";

      const del = document.createElement("button");
      del.type = "button";
      del.className = "row-del";
      del.textContent = "×";

      [check, key, value].forEach((el) => {
        el.addEventListener("input", updateFinalUrlPreview);
        el.addEventListener("change", updateFinalUrlPreview);
      });

      del.addEventListener("click", () => {
        row.remove();
        updateFinalUrlPreview();
      });

      row.append(check, key, value, del);
      container.append(row);
    }

    function getKvRows(container) {
      return Array.from(container.querySelectorAll(".kv-row")).map((row) => {
        const [enabledEl, keyEl, valueEl] = row.querySelectorAll("input");
        return {
          enabled: enabledEl.checked,
          key: keyEl.value.trim(),
          value: valueEl.value
        };
      });
    }

    function setKvRows(container, rows) {
      container.innerHTML = "";
      const safeRows = rows && rows.length ? rows : [{ enabled: true, key: "", value: "" }];
      safeRows.forEach((row) => createKvRow(container, row));
      updateFinalUrlPreview();
    }

    function extractPathKeys(pathTemplate) {
      const matches = pathTemplate.match(/:([a-zA-Z_][a-zA-Z0-9_]*)/g) || [];
      return matches.map((match) => match.slice(1));
    }

    function renderPathParams() {
      const previousValues = {};
      pathParamsList.querySelectorAll("[data-param]").forEach((input) => {
        previousValues[input.dataset.param] = input.value;
      });

      currentPathParamValues = { ...currentPathParamValues, ...previousValues };

      const keys = extractPathKeys(pathInput.value);
      pathParamsList.innerHTML = "";

      if (!keys.length) {
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent = "Sem parâmetros de rota neste endpoint.";
        pathParamsList.append(empty);
        updateFinalUrlPreview();
        return;
      }

      keys.forEach((key) => {
        const row = document.createElement("div");
        row.className = "path-param-row";

        const label = document.createElement("div");
        label.className = "key-chip";
        label.textContent = `:${key}`;

        const input = document.createElement("input");
        input.className = "input";
        input.dataset.param = key;
        input.placeholder = `Valor para :${key}`;
        input.value = currentPathParamValues[key] || "";

        input.addEventListener("input", () => {
          currentPathParamValues[key] = input.value;
          updateFinalUrlPreview();
        });

        row.append(label, input);
        pathParamsList.append(row);
      });

      updateFinalUrlPreview();
    }

    function resolvePathTemplate(pathTemplate) {
      let resolvedPath = pathTemplate.trim() || "/";
      const keys = extractPathKeys(resolvedPath);

      keys.forEach((key) => {
        const value = currentPathParamValues[key];
        if (value !== undefined && value !== null && value !== "") {
          resolvedPath = resolvedPath.replace(`:${key}`, encodeURIComponent(value));
        }
      });

      return resolvedPath;
    }

    function buildFinalUrl() {
      const baseUrl = baseUrlInput.value.trim();
      const pathTemplate = pathInput.value.trim();

      if (!baseUrl || !pathTemplate) {
        return "";
      }

      let url = `${baseUrl.replace(/\/+$/, "")}/${resolvePathTemplate(pathTemplate).replace(/^\/+/, "")}`;

      const activeQuery = getKvRows(queryRows).filter((row) => row.enabled && row.key);
      if (activeQuery.length) {
        const searchParams = new URLSearchParams();
        activeQuery.forEach((row) => searchParams.append(row.key, row.value));
        url += `?${searchParams.toString()}`;
      }

      return url;
    }

    function updateFinalUrlPreview() {
      const url = buildFinalUrl();
      finalUrlPreview.textContent = url ? `URL final: ${url}` : "URL final: defina Base URL e Path";
    }

    function toggleBodyEnabled() {
      const mode = bodyMode.value;
      const disable = mode === "none";
      bodyInput.disabled = disable;
      if (disable) {
        bodyInput.placeholder = "Body desabilitado para esta requisição.";
      } else if (mode === "json") {
        bodyInput.placeholder = '{"title":"Dev","company":"Empresa","location":"Remoto"}';
      } else {
        bodyInput.placeholder = "Texto bruto da requisição";
      }
    }

    function formatJsonBody() {
      if (bodyMode.value !== "json" || !bodyInput.value.trim()) {
        return;
      }

      try {
        const parsed = JSON.parse(bodyInput.value);
        bodyInput.value = JSON.stringify(parsed, null, 2);
      } catch (error) {
        alert(`JSON inválido: ${error.message}`);
      }
    }

    function setStatusChip(status) {
      statusChip.className = "chip";

      if (typeof status === "number" && status >= 200 && status < 300) {
        statusChip.classList.add("good");
      } else if (typeof status === "number" && status >= 400 && status < 500) {
        statusChip.classList.add("warn");
      } else {
        statusChip.classList.add("bad");
      }

      statusChip.textContent = `Status: ${status}`;
    }

    function stringifyForScreen(value) {
      if (typeof value === "string") {
        return value;
      }

      try {
        return JSON.stringify(value, null, 2);
      } catch (error) {
        return String(value);
      }
    }

    function prettyResponseBody(rawText, responseContentType) {
      if (!rawText) {
        return "(sem body)";
      }

      const looksJson = responseContentType.includes("application/json") || /^[\[{]/.test(rawText.trim());
      if (!looksJson) {
        return rawText;
      }

      try {
        return JSON.stringify(JSON.parse(rawText), null, 2);
      } catch (error) {
        return rawText;
      }
    }

    function addToHistory(entry) {
      localHistory.unshift(entry);
      if (localHistory.length > 20) {
        localHistory.pop();
      }
      renderHistory();
    }

    function renderHistory() {
      historyList.innerHTML = "";

      if (!localHistory.length) {
        const empty = document.createElement("div");
        empty.className = "history-empty";
        empty.textContent = "Nenhuma requisição enviada ainda.";
        historyList.append(empty);
        return;
      }

      localHistory.forEach((entry) => {
        const item = document.createElement("div");
        item.className = "history-item";
        item.textContent = `${entry.method} ${entry.path} -> ${entry.status} (${entry.time}ms)`;
        historyList.append(item);
      });
    }

    function buildRequestPreview(method, url, headers, payload) {
      const requestShape = {
        method,
        url,
        headers,
        body: payload
      };

      requestPreview.textContent = stringifyForScreen(requestShape);
    }

    async function sendRequest() {
      const method = methodSelect.value;
      const url = buildFinalUrl();
      const start = performance.now();
      const missingPathParams = extractPathKeys(pathInput.value.trim()).filter((key) => {
        const value = currentPathParamValues[key];
        return value === undefined || value === null || String(value).trim() === "";
      });

      if (!url) {
        alert("Defina Base URL e Path antes de enviar.");
        return;
      }

      if (missingPathParams.length) {
        alert(`Preencha os path params: ${missingPathParams.join(", ")}`);
        return;
      }

      const headerRowsData = getKvRows(headerRows).filter((row) => row.enabled && row.key);
      const headers = {};
      headerRowsData.forEach((row) => {
        headers[row.key] = row.value;
      });

      const options = { method, headers };
      let requestPayload = null;

      const shouldSendBody = !["GET", "HEAD"].includes(method) && bodyMode.value !== "none";
      if (shouldSendBody) {
        if (bodyMode.value === "json") {
          try {
            requestPayload = bodyInput.value.trim() ? JSON.parse(bodyInput.value) : {};
            options.body = JSON.stringify(requestPayload);
            if (!Object.keys(headers).some((key) => key.toLowerCase() === "content-type")) {
              options.headers["Content-Type"] = "application/json";
            }
          } catch (error) {
            setStatusChip("LOCAL_ERROR");
            timeChip.textContent = "Tempo: -";
            sizeChip.textContent = "Tamanho: -";
            responseBody.textContent = `JSON inválido no body: ${error.message}`;
            responseHeaders.textContent = "-";
            buildRequestPreview(method, url, options.headers, bodyInput.value);
            return;
          }
        } else {
          requestPayload = bodyInput.value;
          options.body = requestPayload;
          if (!Object.keys(headers).some((key) => key.toLowerCase() === "content-type")) {
            options.headers["Content-Type"] = "text/plain";
          }
        }
      }

      buildRequestPreview(method, url, options.headers, requestPayload);

      try {
        const response = await fetch(url, options);
        const rawText = await response.text();
        const elapsed = Math.round(performance.now() - start);
        const contentType = response.headers.get("content-type") || "";

        lastResponseText = prettyResponseBody(rawText, contentType);
        responseBody.textContent = lastResponseText;

        const responseHeadersObj = Object.fromEntries(response.headers.entries());
        responseHeaders.textContent = stringifyForScreen(responseHeadersObj);

        setStatusChip(response.status);
        timeChip.textContent = `Tempo: ${elapsed}ms`;
        sizeChip.textContent = `Tamanho: ${rawText.length} bytes`;

        addToHistory({
          method,
          path: pathInput.value.trim() || "(path vazio)",
          status: response.status,
          time: elapsed
        });
      } catch (error) {
        const elapsed = Math.round(performance.now() - start);
        setStatusChip("NETWORK_ERROR");
        timeChip.textContent = `Tempo: ${elapsed}ms`;
        sizeChip.textContent = "Tamanho: -";
        responseBody.textContent = `Erro de rede: ${error.message}`;
        responseHeaders.textContent = "-";

        addToHistory({
          method,
          path: pathInput.value.trim() || "(path vazio)",
          status: "NETWORK_ERROR",
          time: elapsed
        });
      }
    }

    async function testConnection() {
      connText.textContent = "Testando...";
      connText.style.color = "var(--muted)";

      try {
        const url = `${baseUrlInput.value.trim().replace(/\/+$/, "")}/api/jobs?limit=1`;
        const response = await fetch(url);

        if (response.ok) {
          connText.textContent = "Conectado";
          connText.style.color = "var(--good)";
        } else {
          connText.textContent = `Resposta ${response.status}`;
          connText.style.color = "var(--warn)";
        }
      } catch (error) {
        connText.textContent = "Servidor não encontrado";
        connText.style.color = "var(--bad)";
      }
    }

    function loadEndpoint(index) {
      const endpoint = endpointCollection[index];
      if (!endpoint) return;

      activeEndpointIndex = index;
      setCollectionActive(index);

      methodSelect.value = endpoint.method;
      pathInput.value = endpoint.path;

      currentPathParamValues = { ...(endpoint.pathParams || {}) };
      renderPathParams();

      setKvRows(queryRows, endpoint.query || []);
      setKvRows(headerRows, endpoint.headers || []);

      bodyMode.value = endpoint.bodyMode || "none";
      bodyInput.value = endpoint.body || "";
      toggleBodyEnabled();

      bugHint.textContent = endpoint.hint || "Sem dica para este endpoint.";
      requestNote.textContent = endpoint.note || "";

      updateFinalUrlPreview();
    }

    function setupRequestTabs() {
      const buttons = document.querySelectorAll("#requestTabs .tab-btn");
      const panels = document.querySelectorAll(".tab-panel");

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const tabName = button.dataset.tab;

          buttons.forEach((btn) => btn.classList.toggle("active", btn === button));
          panels.forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.panel === tabName);
          });
        });
      });
    }

    function setupResponseTabs() {
      const buttons = document.querySelectorAll("#responseTabs .tab-btn");
      const panels = document.querySelectorAll(".resp-pane");

      buttons.forEach((button) => {
        button.addEventListener("click", () => {
          const tabName = button.dataset.respTab;

          buttons.forEach((btn) => btn.classList.toggle("active", btn === button));
          panels.forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.respPanel === tabName);
          });
        });
      });
    }

    function copyResponse() {
      const text = lastResponseText || responseBody.textContent;
      navigator.clipboard.writeText(text).then(() => {
        const oldLabel = document.getElementById("copyRespBtn").textContent;
        document.getElementById("copyRespBtn").textContent = "Copiado";
        setTimeout(() => {
          document.getElementById("copyRespBtn").textContent = oldLabel;
        }, 1200);
      }).catch(() => {
        alert("Não foi possível copiar a resposta.");
      });
    }

    function bindEvents() {
      document.getElementById("sendBtn").addEventListener("click", sendRequest);
      document.getElementById("pingBtn").addEventListener("click", testConnection);
      document.getElementById("addQueryBtn").addEventListener("click", () => createKvRow(queryRows, { enabled: true, key: "", value: "" }));
      document.getElementById("addHeaderBtn").addEventListener("click", () => createKvRow(headerRows, { enabled: true, key: "", value: "" }));
      document.getElementById("formatJsonBtn").addEventListener("click", formatJsonBody);
      document.getElementById("copyRespBtn").addEventListener("click", copyResponse);

      [baseUrlInput, methodSelect, pathInput].forEach((el) => {
        el.addEventListener("input", updateFinalUrlPreview);
        el.addEventListener("change", updateFinalUrlPreview);
      });

      pathInput.addEventListener("input", renderPathParams);
      bodyMode.addEventListener("change", toggleBodyEnabled);

      document.addEventListener("keydown", (event) => {
        const isCmdCtrlEnter = (event.metaKey || event.ctrlKey) && event.key === "Enter";
        if (isCmdCtrlEnter) {
          event.preventDefault();
          sendRequest();
        }
      });
    }

    function init() {
      renderCollection();
      setupRequestTabs();
      setupResponseTabs();
      bindEvents();

      setKvRows(queryRows, [{ enabled: true, key: "", value: "" }]);
      setKvRows(headerRows, [{ enabled: true, key: "Accept", value: "application/json" }]);
      loadEndpoint(0);
      updateFinalUrlPreview();
    }

    init();
  </script>
</body>
</html>
